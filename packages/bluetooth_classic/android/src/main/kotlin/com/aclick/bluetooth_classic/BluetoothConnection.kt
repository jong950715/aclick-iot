package com.aclick.bluetooth_classic

import android.bluetooth.BluetoothDevice
import android.bluetooth.BluetoothSocket
import android.content.Context
import android.util.Log
import io.flutter.plugin.common.MethodChannel
import java.io.InputStream
import java.io.IOException
import java.io.OutputStream
import java.util.*
import kotlinx.coroutines.*

private const val TAG = "BluetoothConnection"

/**
 * Î∏îÎ£®Ìà¨Ïä§ Ïó∞Í≤∞ Í¥ÄÎ¶¨ ÌÅ¥ÎûòÏä§
 * 
 * @param device Ïó∞Í≤∞Ìï† Î∏îÎ£®Ìà¨Ïä§ Ïû•Ïπò
 * @param context Ïï± Ïª®ÌÖçÏä§Ìä∏
 * @param channel FlutterÍ∞Ä Ïù¥Î≤§Ìä∏Î•º Î∞õÏùÑ Ïàò ÏûàÎäî Î©îÏÑúÎìú Ï±ÑÎÑê
 * @param uuid Ïó∞Í≤∞Ïóê ÏÇ¨Ïö©Ìï† UUID (Í∏∞Î≥∏Í∞íÏùÄ SPP UUID)
 * @param existingSocket Í∑∏Î£π ÏÜåÏú†ÏûêÎ°úÎ∂ÄÌÑ∞ Ïù¥ÎØ∏ Î∞õÏùÄ ÏÜåÏºìÏù¥ ÏûàÎäî Í≤ΩÏö∞ ÏßÄÏ†ï (Í∏∞Î≥∏Í∞íÏùÄ null)
 */
class BluetoothConnection @JvmOverloads constructor(
    private val device: BluetoothDevice, 
    private val context: Context, 
    private val channel: MethodChannel, 
    private val uuid: UUID = SPP_UUID,
    existingSocket: BluetoothSocket? = null
) {
    companion object {
        // Serial Port Profile UUID - Í∏∞Î≥∏Í∞íÏúºÎ°ú ÏÇ¨Ïö©Îê®
        val SPP_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB")
    }
    
    private var socket: BluetoothSocket? = null
    
    init {
        // ÏÉùÏÑ±ÏûêÏóêÏÑú Ï†ÑÎã¨Î∞õÏùÄ ÏÜåÏºìÏù¥ ÏûàÏúºÎ©¥ ÏÇ¨Ïö©
        if (existingSocket != null) {
            socket = existingSocket
            Log.d(TAG, "üì± Ï†ÑÎã¨Î∞õÏùÄ ÏÜåÏºìÏúºÎ°ú Ï¥àÍ∏∞Ìôî: ${device.address}")
        }
    }
    private var inputStream: InputStream? = null
    private var outputStream: OutputStream? = null
    private var isConnecting = false
    private var isConnected = false
    
    /**
     * ÏÑúÎ≤Ñ ÏÜåÏºìÏùò accept()Î°ú ÏñªÏùÄ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÜåÏºìÏùÑ ÏÇ¨Ïö©ÌïòÏó¨ Ïä§Ìä∏Î¶º ÏÑ§Ï†ï
     * Ïù¥ÎØ∏ ÏÜåÏºìÏù¥ Ï¥àÍ∏∞ÌôîÎêòÏñ¥ ÏûàÎã§Í≥† Í∞ÄÏ†ïÌïòÍ≥† Ïä§Ìä∏Î¶ºÎßå ÏÑ§Ï†ïÌï®
     * 
     * @return Ïä§Ìä∏Î¶º ÏÑ§Ï†ï ÏÑ±Í≥µ Ïó¨Î∂Ä
     */
    fun setupStreamsFromSocket(): Boolean {
        if (socket == null) {
            Log.e(TAG, "‚ùå ÏÜåÏºìÏù¥ nullÏûÑ: ${device.address}")
            return false
        }
        
        Log.d(TAG, "üì¢ ÏÑúÎ≤Ñ ÏÜåÏºìÏóêÏÑú Ïä§Ìä∏Î¶º ÏÑ§Ï†ï: ${device.address}")
        
        try {
            // ÏûÖÏ∂úÎ†• Ïä§Ìä∏Î¶º Ï¥àÍ∏∞Ìôî
            inputStream = socket?.inputStream
            outputStream = socket?.outputStream
            
            if (inputStream == null || outputStream == null) {
                Log.e(TAG, "‚ùå Ïä§Ìä∏Î¶º Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®: ${device.address}")
                return false
            }
            
            // Ïó∞Í≤∞ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            isConnected = true
            isConnecting = false
            
            // Îç∞Ïù¥ÌÑ∞ ÏàòÏã† Î¶¨Ïä§ÎÑà ÏãúÏûë
            startListening()
            
            // FlutterÏóê Ïó∞Í≤∞ ÏÑ±Í≥µ ÏïåÎ¶º
            notifyConnectionEstablished()
            
            Log.d(TAG, "üí° Ïä§Ìä∏Î¶º ÏÑ§Ï†ï ÏôÑÎ£å: ${device.address}")
            return true
            
        } catch (e: IOException) {
            Log.e(TAG, "‚ùå Ïä§Ìä∏Î¶º ÏÑ§Ï†ï Ïò§Î•ò: ${e.message}")
            closeSocket()
            return false
        }
    }
    private var isListening = false
    private var readJob: Job? = null
    private val scope = CoroutineScope(Dispatchers.IO + SupervisorJob())
    
    // ÌÜµÍ≥Ñ Î≥ÄÏàò
    private var packetsReceived = 0
    private var packetsSent = 0
    private var errorCount = 0
    
    init {
        // Í∞ùÏ≤¥ ÏÉùÏÑ± Ïãú ÏûêÎèôÏúºÎ°ú Ïó∞Í≤∞ÌïòÏßÄ ÏïäÏùå
        Log.d(TAG, "‚öôÔ∏è BluetoothConnection Í∞ùÏ≤¥ ÏÉùÏÑ±Îê®: ${device.address}")
    }
    
    /**
     * Î∏îÎ£®Ìà¨Ïä§ Ïû•ÏπòÏóê Ïó∞Í≤∞
     * ÏùºÎ∞òÏ†ÅÏù∏ Ïó∞Í≤∞ ÏãúÎÇòÎ¶¨Ïò§ÏóêÏÑú ÏÇ¨Ïö© (ÎîîÎ∞îÏù¥Ïä§Î•º ÏÑ†ÌÉùÌï¥ÏÑú Ïó∞Í≤∞ÌïòÎäî Í≤ΩÏö∞)
     */
    fun connect(): Boolean {
        if (isConnected) {
            Log.d(TAG, "Ïù¥ÎØ∏ Ïó∞Í≤∞Îê®: ${device.address}")
            return true
        }
        
        if (isConnecting) {
            Log.d(TAG, "Ïó∞Í≤∞ Ï§ë: ${device.address}")
            return false
        }
        
        isConnecting = true
        
        try {
            Log.d(TAG, "üîå ÏÜåÏºì Ïó∞Í≤∞ ÏãúÎèÑ: ${device.address}")
            
            // ÏßÄÏ†ïÎêú Ïª§Ïä§ÌÖÄ UUID ÏÇ¨Ïö©
            Log.d(TAG, "üîë ÏÇ¨Ïö©Ìï† UUID: $uuid")
            socket = device.createRfcommSocketToServiceRecord(uuid)
            
            // Ïó∞Í≤∞ ÏãúÎèÑ
            socket?.connect()
            
            // Ïä§Ìä∏Î¶º Ïó¥Í∏∞ Î∞è Î¶¨Ïä§Îãù ÏãúÏûë
            return setupStreamsAndListen()
            
        } catch (e: IOException) {
            Log.e(TAG, "‚ùå Ïó∞Í≤∞ Ïã§Ìå®: ${e.message}")
            errorCount++
            closeSocket()
            isConnecting = false
            isConnected = false
            return false
        }
    }
    
    /**
     * Ïù¥ÎØ∏ Ïó∞Í≤∞Îêú Ïû•ÏπòÎ•º ÏúÑÌïú ÏÑ§Ï†ï (ACL_CONNECTED Ïù¥Î≤§Ìä∏ÏóêÏÑú Ìò∏Ï∂úÎê®)
     * Ïù¥ÎØ∏ ÏÜåÏºìÏù¥ Ïó∞Í≤∞Îêú Í≤ΩÏö∞, Ïä§Ìä∏Î¶º Í¥ÄÎ†® Ï≤òÎ¶¨Îßå ÏàòÌñâ
     */
    /**
     * Ïù¥ÎØ∏ Ïó∞Í≤∞Îêú Ïû•ÏπòÎ•º ÏúÑÌïú ÏÑ§Ï†ï (ACL_CONNECTED Ïù¥Î≤§Ìä∏ÏóêÏÑú Ìò∏Ï∂úÎê®)
     * Ïù¥ÎØ∏ ÏÜåÏºìÏù¥ Ïó∞Í≤∞Îêú Í≤ΩÏö∞, Ïä§Ìä∏Î¶º Í¥ÄÎ†® Ï≤òÎ¶¨Îßå ÏàòÌñâ
     * 
     * @param externalUuid Ïô∏Î∂ÄÏóêÏÑú Ï†ÑÎã¨Ìïú UUIDÍ∞Ä ÏûàÏúºÎ©¥ ÏÇ¨Ïö©Ìï® (Í∏∞Î≥∏Í∞íÏùÄ null)
     * @return Ïó∞Í≤∞ ÏÑ±Í≥µ Ïó¨Î∂Ä
     */
    fun setupAlreadyConnected(externalUuid: UUID? = null): Boolean {
        if (isConnected) {
            Log.d(TAG, "Ïù¥ÎØ∏ Ïó∞Í≤∞Îê®: ${device.address}")
            return true
        }
        
        Log.d(TAG, "üîå Ïù¥ÎØ∏ Ïó∞Í≤∞Îêú Ïû•Ïπò ÏÑ§Ï†ï: ${device.address}")
        isConnecting = true
        
        // ÏÇ¨Ïö©Ìï† UUID Í≤∞Ï†ï (Ïô∏Î∂ÄÏóêÏÑú Ï†ÑÎã¨Îêú UUIDÎ•º Ïö∞ÏÑ†ÏãúÌïòÍ≥†, ÏóÜÎäî Í≤ΩÏö∞ ÏÉùÏÑ±ÏûêÏóêÏÑú Ï†ÑÎã¨Î∞õÏùÄ UUID ÏÇ¨Ïö©)
        val uuidToUse = externalUuid ?: uuid
        
        try {
            // ÏßÄÏ†ïÎêú Ïª§Ïä§ÌÖÄ UUID ÏÇ¨Ïö©
            Log.d(TAG, "üîë Ïù¥ÎØ∏ Ïó∞Í≤∞Îêú Ïû•ÏπòÏóê ÏÇ¨Ïö©Ìï† UUID: $uuidToUse")
            socket = device.createRfcommSocketToServiceRecord(uuidToUse)
            
            socket?.connect()
            return setupStreamsAndListen()
            
        } catch (e: IOException) {
            Log.e(TAG, "‚ùå Ïù¥ÎØ∏ Ïó∞Í≤∞Îêú Ïû•Ïπò ÏÑ§Ï†ï Ïã§Ìå®: ${e.message}")
            errorCount++
            closeSocket()
            isConnecting = false
            isConnected = false
            return false
        }
    }
    
    /**
     * Ïä§Ìä∏Î¶º Ïó¥Í≥† Î¶¨Ïä§Îãù ÏãúÏûë (ÎÇ¥Î∂Ä Î©îÏÑúÎìú)
     */
    private fun setupStreamsAndListen(): Boolean {
        try {
            // Ïä§Ìä∏Î¶º Ïó¥Í∏∞
            inputStream = socket?.inputStream
            outputStream = socket?.outputStream
            
            // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
            isConnected = true
            isConnecting = false
            
            // Îç∞Ïù¥ÌÑ∞ ÏàòÏã† Î¶¨Ïä§ÎÑà ÏãúÏûë
            startListening()
            
            // FlutterÏóê Ïó∞Í≤∞ ÏÑ±Í≥µ ÏïåÎ¶º
            notifyConnectionEstablished()
            
            Log.d(TAG, "‚úÖ Ïó∞Í≤∞ ÏÑ±Í≥µ: ${device.address}")
            return true
        } catch (e: IOException) {
            Log.e(TAG, "‚ùå Ïä§Ìä∏Î¶º Ïó¥Í∏∞ Ïã§Ìå®: ${e.message}")
            closeSocket()
            isConnected = false
            isConnecting = false
            return false
        }
    }
    
    /**
     * FlutterÏóê Ïó∞Í≤∞ ÏÑ±Í≥µ Ïù¥Î≤§Ìä∏ ÏïåÎ¶º
     */
    private fun notifyConnectionEstablished() {
        scope.launch(Dispatchers.Main) {
            val deviceInfo = mapOf(
                "address" to device.address,
                "name" to (device.name ?: "Unknown Device"),
                "type" to "classic"
            )
            
            channel.invokeMethod("onDeviceConnected", deviceInfo)
        }
    }
    
    /**
     * Îç∞Ïù¥ÌÑ∞ Î¶¨Ïä§Îãù ÏãúÏûë
     */
    private fun startListening() {
        val localInputStream = inputStream // ÏßÄÏó≠ Î≥ÄÏàòÎ°ú Î≥¥Ìò∏
        
        if (isListening || localInputStream == null) {
            Log.w(TAG, "üõ°Ô∏è Î¶¨Ïä§Îãù ÏãúÏûë Ïã§Ìå®: isListening=$isListening, inputStream=${localInputStream != null}")
            return
        }
        
        Log.d(TAG, "üìª Îç∞Ïù¥ÌÑ∞ Î¶¨Ïä§Îãù ÏãúÏûë")
        isListening = true
        readJob = scope.launch(Dispatchers.IO) {
            Log.d(TAG, "üîó Î¶¨Ïä§Îãù ÏΩîÎ£®Ìã¥ ÏãúÏûë")
            val buffer = ByteArray(1024)
            var bytes: Int
            
            try {
                var counter = 0
                while (isActive && isConnected) {
                    if (counter % 30 == 0) { // 30Î≤àÎßàÎã§ Î°úÍ∑∏ Ï∂úÎ†•(Í≥ºÎèÑÌïú Î°úÍπÖ Î∞©ÏßÄ)
                        Log.d(TAG, "üìØ Î¶¨Ïä§Îãù ÏõêÌôú: ÏàòÏã†=$packetsReceived, Ï†ÑÏÜ°=$packetsSent")
                    }
                    counter++
                    
                    // ÌòÑÏû¨ Ïä§Ìä∏Î¶º ÏÉÅÌÉú Ï≤¥ÌÅ¨ Î∞è Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
                    val localBuffer = buffer  // Î°úÏª¨ Ï∞∏Ï°∞Î°ú Î≥µÏÇ¨
                    val streamReadResult = readFromStreamSafely(localBuffer)
                    
                    when {
                        streamReadResult.error != null -> {
                            Log.e(TAG, "‚ö†Ô∏è Ïä§Ìä∏Î¶º ÏùΩÍ∏∞ Ïò§Î•ò: ${streamReadResult.error}")
                            errorCount++
                            break
                        }
                        streamReadResult.bytesRead < 0 -> {
                            Log.w(TAG, "‚ùå ÏÜåÏºì Ïó∞Í≤∞ Ï¢ÖÎ£å: bytesRead=${streamReadResult.bytesRead}")
                            break
                        }
                        streamReadResult.bytesRead > 0 -> {
                            val bytesRead = streamReadResult.bytesRead
                            packetsReceived++
                            val data = localBuffer.copyOfRange(0, bytesRead) 
                            val dataString = String(data)
                            
                            Log.d(TAG, "üì• Îç∞Ïù¥ÌÑ∞ ÏàòÏã†: $bytesRead Î∞îÏù¥Ìä∏ - '$dataString'")
                            
                            // FlutterÏóê Îç∞Ïù¥ÌÑ∞ Ï†ÑÎã¨
                            withContext(Dispatchers.Main) {
                                channel.invokeMethod("onDataReceived", mapOf(
                                    "address" to device.address,
                                    "data" to data.map { it.toInt() and 0xFF }
                                ))
                                Log.d(TAG, "‚úÖ FlutterÏóê Îç∞Ïù¥ÌÑ∞ Ï†ÑÎã¨ ÏôÑÎ£å")
                            }
                        }
                        else -> {
                            Log.d(TAG, "üìã ÏùΩÏùÄ Î∞îÏù¥Ìä∏ ÏóÜÏùå (bytesRead=0)")
                        }
                    }
                }
                Log.d(TAG, "üìö Î¶¨Ïä§Îãù Î£®ÌîÑ Ï¢ÖÎ£å: isActive=$isActive, isConnected=$isConnected")
            } catch (e: Exception) {
                Log.e(TAG, "‚õî Î¶¨Ïä§Îãù Ïä§Î†àÎìú Ïò§Î•ò: ${e.message}")
            } finally {
                // Î£®ÌîÑ Ï¢ÖÎ£å Ïãú Ïó∞Í≤∞ÎèÑ Ï¢ÖÎ£å
                Log.d(TAG, "üî¥ Î¶¨Ïä§Îãù ÏΩîÎ£®Ìã¥ Ï¢ÖÎ£å")
                if (isConnected) {
                    disconnect()
                }
                isListening = false
            }
        }
    }
    
    /**
     * Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°
     */
    fun sendData(data: ByteArray): Boolean {
        if (!isConnected || outputStream == null) {
            Log.e(TAG, "üì§ Ï†ÑÏÜ° Ïã§Ìå®: Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏùå")
            return false
        }
        
        return try {
            outputStream?.write(data)
            outputStream?.flush()
            packetsSent++
            Log.d(TAG, "üì§ Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ°: ${data.size} Î∞îÏù¥Ìä∏")
            true
        } catch (e: IOException) {
            Log.e(TAG, "üì§ Îç∞Ïù¥ÌÑ∞ Ï†ÑÏÜ° Ïò§Î•ò: ${e.message}")
            errorCount++
            disconnect()
            false
        }
    }
    
    /**
     * ÏÜåÏºìÍ≥º Ïä§Ìä∏Î¶º Îã´Í∏∞
     */
    private fun closeSocket() {
        try {
            inputStream?.close()
            outputStream?.close()
            socket?.close()
        } catch (e: IOException) {
            Log.e(TAG, "ÏÜåÏºì Îã´Í∏∞ Ïò§Î•ò: ${e.message}")
        } finally {
            socket = null
            inputStream = null
            outputStream = null
        }
    }
    
    /**
     * Ïä§Ìä∏Î¶ºÏóêÏÑú ÏïàÏ†ÑÌïòÍ≤å Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
     * null Ï∞∏Ï°∞ Î¨∏Ï†úÎ•º Î∞©ÏßÄÌïòÍ∏∞ ÏúÑÌïú Î≥¥Ìò∏ Î©îÏÑúÎìú
     */
    private data class StreamReadResult(val bytesRead: Int, val error: String?)
    
    /**
     * Ïä§Ìä∏Î¶ºÏóêÏÑú ÏïàÏ†ÑÌïòÍ≤å Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞
     */
    private fun readFromStreamSafely(buffer: ByteArray): StreamReadResult {
        // Ïù¥ Ï†ÑÏ≤¥ Î©îÏÑúÎìúÎ•º ÎèôÍ∏∞Ìôî
        // Ïã§Ìñâ Ï§ëÏóê Îã§Î•∏ Ïä§Î†àÎìúÍ∞Ä inputStreamÏùÑ Î≥ÄÍ≤ΩÌïòÏßÄ Î™ªÌïòÍ≤å Ìï®
        return synchronized(this) {
            try {
                // Î°úÏª¨ Î≥ÄÏàòÎ°ú Î≥µÏÇ¨
                val localInputStream = inputStream
                
                if (localInputStream == null) {
                    Log.e(TAG, "üõë ÏùΩÍ∏∞ ÏãúÎèÑ Ï§ë inputStreamÏù¥ nullÏûÖÎãàÎã§")
                    return@synchronized StreamReadResult(-1, "InputStream is null")
                }
                
                if (!isConnected) {
                    Log.e(TAG, "üõë ÏùΩÍ∏∞ ÏãúÎèÑ Ï§ë isConnected=false")
                    return@synchronized StreamReadResult(-1, "Not connected")
                }
                
                Log.d(TAG, "üìù Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞ ÏãúÎèÑ Ï§ë...")
                try {
                    val bytesRead = try {
                        // ÏïàÏ†ÑÌïòÍ≤å ÏùΩÍ∏∞ ÏãúÎèÑ
                        localInputStream.read(buffer)
                    } catch (npe: NullPointerException) {
                        // Îß§Ïö∞ ÎìúÎ¨ºÍ≤å Î∞úÏÉùÌïòÎäî NPEÎ•º Ïû°ÏïÑÏÑú Î°úÍ∑∏
                        Log.e(TAG, "üõë Ïã§Ï†ú read() Ìò∏Ï∂ú Ïãú NPE Î∞úÏÉù!")
                        -1
                    }
                    
                    if (bytesRead > 0) {
                        Log.d(TAG, "üìù Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞ ÏÑ±Í≥µ: $bytesRead Î∞îÏù¥Ìä∏")
                        StreamReadResult(bytesRead, null)
                    } else if (bytesRead == 0) {
                        Log.d(TAG, "üìã ÏùΩÏùÄ Î∞îÏù¥Ìä∏ ÏóÜÏùå")
                        StreamReadResult(0, null)
                    } else {
                        Log.w(TAG, "‚ùå Ïó∞Í≤∞ Ï¢ÖÎ£å Í∞êÏßÄ: read() Î∞òÌôòÍ∞í=$bytesRead")
                        // Ïó∞Í≤∞Ïù¥ Ï¢ÖÎ£åÎêú Í≤ΩÏö∞, Ïó∞Í≤∞ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                        isConnected = false
                        StreamReadResult(bytesRead, "Connection closed")
                    }
                } catch (e: IOException) {
                    Log.e(TAG, "‚ö†Ô∏è Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞ IOException: ${e.message}")
                    StreamReadResult(-1, "IOException: ${e.message}")
                }
            } catch (e: Exception) {
                Log.e(TAG, "‚õî Îç∞Ïù¥ÌÑ∞ ÏùΩÍ∏∞ Ïò§Î•ò: ${e.javaClass.simpleName}: ${e.message}")
                StreamReadResult(-1, "${e.javaClass.simpleName}: ${e.message}")
            }
        }
    }
    
    /**
     * Ïó∞Í≤∞ Ï¢ÖÎ£å Î∞è ÏûêÏõê Ìï¥Ï†ú
     */
    fun disconnect() {
        if (!isConnected && !isConnecting) return
        
        // ÏùΩÍ∏∞ ÏûëÏóÖ Ï∑®ÏÜå
        readJob?.cancel()
        isListening = false
        
        // ÏÜåÏºì Îã´Í∏∞
        closeSocket()
        
        // ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
        isConnected = false
        isConnecting = false
        
        // FlutterÏóê Ïó∞Í≤∞ Ï¢ÖÎ£å ÏïåÎ¶º
        scope.launch(Dispatchers.Main) {
            channel.invokeMethod("onDeviceDisconnected", mapOf(
                "address" to device.address,
                "name" to (device.name ?: "Unknown Device")
            ))
        }
        
        Log.d(TAG, "üîå Ïó∞Í≤∞ Ï¢ÖÎ£å: ${device.address}")
    }
    
    /**
     * Ïó∞Í≤∞Îêú BluetoothDevice Í∞ùÏ≤¥ Î∞òÌôò
     */
    fun getDevice(): BluetoothDevice {
        return device
    }
    
    /**
     * Ïó∞Í≤∞ ÏÉÅÌÉú Î∞òÌôò
     */
    fun isConnected(): Boolean {
        return isConnected && socket?.isConnected == true
    }
    
    /**
     * Ïó∞Í≤∞ ÌÜµÍ≥Ñ Î∞òÌôò
     */
    fun getConnectionStats(): Map<String, Any> {
        return mapOf(
            "packetsReceived" to packetsReceived,
            "packetsSent" to packetsSent,
            "errorCount" to errorCount,
            "isConnected" to isConnected(),
            "deviceAddress" to device.address
        )
    }
}
